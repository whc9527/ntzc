本文简单介绍下ntzc的编译安装过程以及使用。

1. 准备工作
> 首先检查开发机上是否有linux kernel的代码，如果没有的话首先下载。然后编译trunk/zc中的代码，结果会生成一个ntzc.ko模块和一些网卡驱动的内核模块，接着编译trunk/nta中的代码，生成send和sniff测试文件。
> 查看测试机的网卡，如果在虚拟机中，可能是pcnet32，如果是网络设备，可能是e1000或者e1000e。我们以pcnet32为例，将测试机使用的网卡所对应的驱动模块重命名，例如pcnet32.ko -> zwzpcnet32.ko。将开发机上的ntzc.ko，pcnet.ko，send以及sniff传入测试机中。
> 重启测试机，这时候由于系统找不到网卡对应的驱动，于是显示网络不通，依次加载ntzc.ko和pcnet.ko（insmod ntzc.ko；insmod pcnet.ko），顺序一定要对。在这个时候，经常会发生问题，总体来说有三类：一是加载次序错误；二是提示ntzc.ko或者pcnet.ko依赖的某些模块没有加载，手工加载上述模块就成；三是一加载系统就崩，如果你没有对程序做改动，那么崩的原因基本上是因为trunk/zc/zc\_comm.h文件中BVL\_BITS较大引起的，将其改小即可。

2. send程序
> Send程序比较简单，就是往eth0口不停的发包，参数有四个-c为cpu数量，-s为包的大小，-r为包预留大小，-f为映射文件，除了cpu数目，其他都有默认值，可以不指定。例如，当测试机有一个cpu时，可以通过./send –c 1来发包。需要说明的是-c指定的数目可以比实际的cpu数量大，但不能小，否则可能在运行过程中出错。

3. sniff程序
> Sniff 程序参数稍微多一点点。需要指定两个参数，-c同样代表cpu数目，-i代表监听的接口，一般都是按eth0，eth1， eth2的顺序从0开始递增的。例如要监听eth2的数据包，cpu的书目为2。则命令为：./sniff –c 2 –i 2。